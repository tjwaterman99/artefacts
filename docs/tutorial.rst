Tutorial
========

For this tutorial we are going to use artefacts to build a simple "conventions linter" for our dbt project. This linter will scan all of the models in our project and alert us if any of the models are missing a description.

You could imagine running this "conventions linter" script as part of your CI/CD process on Github Actions, Circle CI, Bamboo, or a similar system. If the script identifies a model without a description, it can finish with an error code, alerting a code reviewer that a model is missing documentation. This will make it easier to keep high standards for our project's documentation!

To create this linter, we'll need to 1) compile [#f1]_ our dbt project, 2) add a python script to our project that uses the artefacts API to analyze the project's models, and then 3) run the script during our CI/CD process. We'll assume that the CI/CD process will use Github actions, and will share a simple Github workflow that runs the script, but it can be adapted to any CI/CD process.

Compiling a dbt project
-----------------------

To compile a dbt project, simply navigate to the project root and run dbt's :code:`compile` command from your terminal.

.. code-block:: bash

    $ cd dbt_projects/jaffle_shop
    $ dbt compile

If all goes okay, you should now see a folder in your project's root directory called :code:`target`. This folder will contain several `artifacts` generated by the :code:`compile` command. (The exact artifacts in your :code:`target` directory might be different than the ones shown below, depending on which dbt commands you've ran previously.)

.. code-block:: bash

    $ ls target

    compiled/
    run/
    catalog.json
    graph.gpickle
    index.html
    manifest.json
    partial_parse.msgpack
    
It turns out that the :code:`manifest.json` artifact contains the details of all the models in your dbt project. 

But if you open that file in your text editor, you'll likely see a hot mess of complex data. In fact, the :code:`manifest.json` file generated by my company's project is tens of thousands of lines long. 

While it's easy to parse that json yourself using Python's :code:`json.load` function, actually using the complex dictionaries returned by that function are not easy. You might also consider using :code:`dbt-core` to parse the manifest, but that approach is undocumented, and you'll need to read the complex Python source code to understand how to use it. Additionally, the Python APIs in dbt are not stable, so your code could break any time!

Instead, we can use artefacts simple, documented, stable API for parsing the dbt artifact. Let's try that!



.. rubric:: Footnotes

.. [#f1] Compiling your project means that dbt will scan all the sql and yaml files, render the Jinja in your SQL, identify which models depend on other models via the `ref` function, and so on. dbt will save the result of that work in an artifact called `manifest.json`.

